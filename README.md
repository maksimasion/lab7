# Лабораторная работа № 7. Дифференциальные уравнения. Задача Коши.

Выполнил студент группы    <br>
Гурьянов Максим Олегович <br>

## Вариант № 11
Решить методом Тейлора 4-го порядка задачу Коши<br>
<br>
![](Formuls/Func.png),<br>
![](Formuls/nu.png),  ![](Formuls/eqn.png)<br>
<br>
с заданной относительной точностью ![](Formuls/tochnost.png)<br>
Требуется построение графиков решения ![](Formuls/graph.png), а также фазовых траекторий. За своевременное выполнение<br>
задания начисляется **6 баллов**.<br>
Дополнительные **3 балла** будут начислены, если будет найдено точное решение и оно будет сопоставлено<br>
(построены соответствующие разностные графики) с полученным приближенным решением.<br>
Еще **3 балла** будут начислены, если решение задачи Коши будет найдено с помощью встроенных функций и<br>
оно также будет сопоставлено (построены соответствующие разностные графики) с исходным приближенным<br>
решением.<br><br>
## Теоретическая часть
Уравнение <br><br>
![](Formuls/DU.png), ![](Formuls/inter.png),<br><br>
связывающее неизвестную функцию ![](Formuls/yx.png), независимую переменную ![](Formuls/x.png) и производные<br>
![](Formuls/svyaz.png) неизвестной ф-ции, называется *обыкновееным дифференциальным уравнением*.<br>
*Порядком* дифференциального уравнения называется порядок старшей производной в нем.<br>
В *задаче Коши* для дифференциального уравнения *n*-го порядка искомая ф-ция *y(x)*, кроме самого<br>
диффер-го ур-я должна удовлетворять заданным начальным условиям:<br>
![](Formuls/nu1.png),<br>
![](Formuls/nu2.png),<br>
![](Formuls/dots.png),<br>
![](Formuls/nu3.png).<br>
<br>
При численном решении *задачи Коши* ищется последовательность векторов ![](Formuls/pv.png), являющихся приближениями<br>
для значений решения ![](Formuls/pv2.png) на множестве точек сетки<br><br> 
![](Formuls/setka.png),<br><br> 
где  ![](Formuls/shag.png)- шаг сетки. Мы используем метод с равномерной сеткой, т.е. сеткой с постоянным шагом ![](Formuls/shag1.png).<br>
Основное предположение, которое мы принимаем, состоит в непрерывности дифференцируемых ф-ций.<br>
<br>
***Суть метода разложения в ряд Тейлора:***<br>
Простейшим способом построения приближенного решения в точке ![](Formuls/x_n1.png) 
сетки ![](Formuls/omegan.png) является способ, основанный на разложении решения в ряд
Тейлора в предыдущей точке сетки ![](Formuls/xn.png) по степеням шага  ![](Formuls/h.png):<br><br>
![](Formuls/pr1.png) ![](Formuls/.png) ,<br>
![](Formuls/omega.png)<br>
Вместо этого ряда можно взять конечный его отрезок.<br>
Т.к по условию порядок формулы Тейлора = 4, то значение ф-ции в каждой точке координатной<br>
сетки будет выражаться следующим образом: <br>
![](Formuls/T.png) *(1)*<br>
Продифференцируем ее 2 раза относительно *x*:<br>
![](Formuls/T1.png) *(2)*<br>
![](Formuls/T2.png) *(3)*<br>
<br>
**Алгоритм:**<br>
Выбираем начальный шаг ![](Formuls/h.png) Например, ![](Formuls/shagg.png).<br>
Нам известно значение ф-ции и первых 2-х ее производных в начальной точке ![](Formuls/nt.png):<br>
![](Formuls/y00.png), ![](Formuls/y10.png), ![](Formuls/y20.png)<br>
А значения оставшихся производных в этой точке можно найти.<br>
Запишем нашу ф-цию в виде: <br>
![](Formuls/p3.png) *(4)*<br>
И найдем выражения для 4-6 производных, продифференцировав *(4)*:<br>
![](Formuls/p4.png) *(5)*<br>
![](Formuls/p5.png) *(6)*<br>
![](Formuls/p6.png) *(7)*<br>
<br>
Находим по ф-лам (4), (5), (6), (7):<br>
![](Formuls/y30.png),<br>
![](Formuls/y40.png),<br>
![](Formuls/y50.png),<br>
![](Formuls/y60.png)<br>
Теперь т.к нам известны значения всех производных, можем вычислить значение в точке *x1 = x0 + h* по формуле (1):<br>
![](Formuls/y1.png) <br>
<br>
Теперь найдем по ф-лам (2) - (7)<br>
![](Formuls/y51.png),<br>
![](Formuls/y61.png),<br>
![](Formuls/y11.png),<br>
![](Formuls/y21.png),<br>
![](Formuls/y31.png),<br>
![](Formuls/y41.png),<br>
<br>
т.к нам известны значения всех производных, можем вычислить значение в точке *x2 = x1 + h* по формуле (1):<br>
![](Formuls/y2.png) <br>
![](Formuls/dots.png) ![](Formuls/dots.png) ![](Formuls/dots.png) <br>
<br>
Находим по ф-лам (2) - (7)<br>
![](Formuls/y5n.png), <br>
![](Formuls/y6n.png),<br>
![](Formuls/y1n.png),<br>
![](Formuls/y2n.png),<br>
![](Formuls/y3n.png),<br>
![](Formuls/y4n.png), <br><br>

т.к нам известны значения всех производных, можем вычислить значение в точке ![](Formuls/xnn.png) по формуле (1).<br>
Находим все значения ф-ции в точках сетки до тех пор, пока ![](Formuls/xn.png) не будет равно ![](Formuls/b.png).<br>
<br><br>

Уменьшаем шаг: делим его пополам или на любое другое число и повторяем алгоритм<br>
Проверяем условие останова: ![](Formuls/ost.png), где *e* - заданная нами точность, ![](Formuls/yn1.png) - найденное значение в точке
*x=b* на предыдущем шаге , ![](Formuls/y22.png) - найденное значение в точке *x=b* на текущем шаге.<br>
Если условие выполняется, алгоритм заканчивает работу. И  решением является последнее найденное приближение. Иначе, снова уменьшаем 
шаг и повторем алгоритм заново.<br>
<br>
Т.к шаг *h -> 0* , значения производной будем вычислять по формуле ![](Formuls/proizv.png)<br><br>
## Практическая часть
Моя работа состоит из 2-х программ: <br>
1) Программа с реализацией поиска значений ф-ций *y(x)*, *y'(x)*, *y'(y)* написанная на языке C++<br>
2) Программа для отрисовки ф-ций, написанная на Python<br><br>

Программа на C++ состоит из 1-го файла **`lab7.cpp`**<br><br>

Структура программы:<br>
* В начале программы продключаются библиотеки: <br>
     `iostream` - стандартная библиотека ввода/вывода<br>
     `cmath` - стандартная библиотека для выполнения математических операций <br>
     `fstream` - библиотека для чтения/записи данных из/в файл <br>
* `long double dy3_(double x)` - функция ,зависящая от переменной *x* и выражающая 3-ю производную.<br>
* `long double dy4_(double x)` - функция , выражающая 4-ю производную. (получена диффер-ем по *x* ф-ции `dy3_(x)`)<br>
* `long double dy5_(double x)` - функция , выражающая 5-ю производную. (получена диффер-ем ф-ции `dy4_(x)`)<br>
* `long double dy6_(double x)` - функция , выражающая 6-ю производную. (получена диффер-ем ф-ции `dy5_(x)`)<br>
* `long double Teilor()` - разложение в ряд Тейлора (с ее помощью находим значние ф-ции в следующей точке при помощи значения в предыдущей)<br>
* `long double T1()` - функция , выражающая 1-ю производную. (получена диффер-ем ф-ции `Teilor()`)<br>
* `long double T2()` - функция , выражающая 2-ю производную. (получена диффер-ем ф-ции `T1()`)<br>
* `int fact(int x)` - функция, вычисляющая факториал *x*<br>
* `long double dy[7]` - массив значений производных от 0 порядка (самой ф-ции) до 6 включильно<br>
* `long double a = 0, b = 2` - отрезок дифференцирования по оси *OX*<br>
* `long double h =(b-a)/2` - начальный шаг по оси *OX*<br>
* `double e = 0.01` - точность, с которой нужно найти решение<br>
<br>

* В методе `int main()` происходит вычисление значений ф-ции и ее производной с последующей записью их в файл .  
В файл `Func.txt` записываются значения *x* и *y(x)*,  в `Proizv.txt` - значения *x* и производной *y'(x)*, в `FazTraekt.txt` - значения *y(x)* и *y'(x)*.<br><br>

Программа на Python состоит из 1-го файла **`graph.py`**<br>

В ней строятся графики **y(x)** , **y'(x)**, **y'(y)** по данным из файлов `Func.txt`, `Proizv.txt` и `FazTraekt.txt` соответственно.<br><br>

**Порядок компилляции/запуска:**<br>
1. Компиллируем и запускаем файл **`lab7.cpp`** из командной строки при помощи команды:<br>
`g++ lab7.cpp -o lab7.o`<br><br>
2. Запускаем из командной строки `lab7.o`<br><br>
2. Запускаем файл **`graph.py`** в программе Spyder (или другой, поддерживающей язык Python)<br>
### Результаты
В результате работы программы были найдены значения  **y(x)** , **y'(x)** с точностью **e = 0.01** и построены графики этих функций. Также построен график фазовой траектории **y'(y)**.<br>
Ниже приведен рисунок с изображением функций.<br>
![](Formuls/graphic.jpg)
